'use strict';

const node_fs = require('node:fs');
const promises = require('node:fs/promises');
const kit = require('@nuxt/kit');
const chalk = require('chalk');
const globby = require('globby');
const pathe = require('pathe');
const ufo = require('ufo');
const untyped = require('untyped');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);

const SUPPORTED_EXTENSIONS = ["mp3", "mpeg", "opus", "ogg", "oga", "wav", "aac", "caf", "m4a", "mp4", "weba", "webm", "dolby", "flac"];
const DEFAULTS = {
  scan: "public/sounds/",
  sounds: {}
};
const CONFIG_KEY = "sound";
const module$1 = kit.defineNuxtModule({
  meta: {
    name: "@vueuse/sound",
    configKey: CONFIG_KEY,
    compatibility: {
      nuxt: ">=3.0.0",
      bridge: true
    },
    defaults: DEFAULTS
  },
  defaults: DEFAULTS,
  async setup(options, nuxt) {
    const logger = kit.useLogger("\u{1F3BA}");
    const { resolve } = kit.createResolver((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('nuxt.cjs', document.baseURI).href)));
    const resolveRuntimeModule = (path) => kit.resolveModule(path, { paths: resolve("./runtime") });
    nuxt.options.runtimeConfig.public = nuxt.options.runtimeConfig.public || {};
    nuxt.options.runtimeConfig.public.sound = nuxt.options.runtimeConfig.public.sound || {
      scanPath: typeof options.scan === "string" ? options.scan : "public/sounds/"
    };
    const runtimeConfig = nuxt.options.runtimeConfig.public.sound;
    const soundsBuildDir = pathe.join(nuxt.options.buildDir, "sounds");
    const generateSoundType = async (schema) => {
      return untyped.generateTypes(await untyped.resolveSchema(schema), {
        addExport: true,
        allowExtraKeys: true,
        interfaceName: "AvailableSounds"
      });
    };
    const writeSchema = async (schema) => {
      const schemaPath = pathe.join(nuxt.options.buildDir, "sounds/index.d.ts");
      const pathType = `export type SoundsPaths = ${Object.keys(schema).map((path) => `'${path}'`).join(" | \n")}`;
      const configType = await generateSoundType(schema);
      await promises.writeFile(schemaPath, `${pathType}

${configType}`);
    };
    const writeOptions = async (schema) => {
      const optionsPath = pathe.join(nuxt.options.buildDir, "sounds/index.ts");
      await promises.writeFile(optionsPath, `export default ${JSON.stringify(schema, null, 2)}`);
    };
    const writeTargets = async (schema) => {
      if (!node_fs.existsSync(soundsBuildDir)) await promises.mkdir(soundsBuildDir, { recursive: true });
      await writeOptions(schema);
      await writeSchema(schema);
    };
    let soundsConfig = options.sounds;
    if (options.scan) {
      runtimeConfig.scanPath = runtimeConfig.scanPath || "public/sounds/";
      if (typeof options.scan === "string") {
        runtimeConfig.scanPath = options.scan;
      }
      const getScannedSounds = async () => {
        let scannedSounds = {};
        try {
          const paths = (await globby.globby(pathe.join(nuxt.options.rootDir, runtimeConfig.scanPath, `**/*.{${SUPPORTED_EXTENSIONS.join(",")}}`))).map(
            (path) => ufo.withLeadingSlash(path.replace(pathe.join(nuxt.options.rootDir), "").replace("public/", ""))
          );
          scannedSounds = paths.reduce((acc, path) => {
            acc[path] = {
              src: path,
              volume: 1
            };
            return acc;
          }, scannedSounds);
        } catch (e) {
          console.log(e);
        }
        return scannedSounds;
      };
      soundsConfig = { ...await getScannedSounds(), ...soundsConfig };
      nuxt.hook("builder:watch", async (type, path) => {
        if (path.includes(runtimeConfig.scanPath)) {
          if (type === "add") {
            logger.success(`You added the sound: ${chalk__default.greenBright(path.replace(runtimeConfig.scanPath, ""))}`);
          }
          if (type === "unlink") {
            logger.success(`You removed the sound: ${chalk__default.redBright(path.replace(runtimeConfig.scanPath, ""))}`);
          }
          const sounds = await getScannedSounds();
          await writeTargets({ ...sounds, ...options.sounds });
        }
      });
    }
    await writeTargets(soundsConfig);
    nuxt.hook("build:before", async () => await writeTargets(soundsConfig));
    nuxt.hook("prepare:types", async () => await writeTargets(soundsConfig));
    if (!nuxt.options.build.transpile) nuxt.options.build.transpile = [];
    const transpileList = ["defu", "@vueuse/sound", "howler"];
    transpileList.forEach((pkgName) => {
      if (!nuxt.options.build.transpile.includes(pkgName)) nuxt.options.build.transpile.push(pkgName);
    });
    nuxt.hook("prepare:types", (opts) => {
      opts.references.push({
        path: pathe.join(nuxt.options.buildDir, "/sounds/sounds.d.ts")
      });
      opts.tsConfig.compilerOptions = opts.tsConfig.compilerOptions || {};
      opts.tsConfig.compilerOptions.paths = opts.tsConfig.compilerOptions.paths || {};
      opts.tsConfig.compilerOptions.paths["#sounds"] = ["./.nuxt/sounds/index"];
      opts.tsConfig.compilerOptions.paths["#sounds/types"] = ["./.nuxt/sounds/index.d.ts"];
    });
    kit.addPlugin({
      src: resolveRuntimeModule("./plugins/sounds.ts")
    });
    kit.addImports([
      {
        name: "useSound",
        as: "useSound",
        from: resolveRuntimeModule("./composables/use-sound.ts")
      }
    ]);
  }
});

module.exports = module$1;
